------------------------------------------------------------
-- Ficha 3 - Tarefa 2
-- Tema: Avaliação de expressões com map e filter
-- Autor: Eduardo Nunes
------------------------------------------------------------

module Tarefa2 where

------------------------------------------------------------
-- Nesta tarefa vamos avaliar manualmente cada expressão,
-- explicando passo a passo como map e filter atuam.
--
-- IMPORTANTE:
--  - map aplica uma função a TODOS os elementos da lista
--  - filter mantém APENAS os elementos que satisfazem a condição
------------------------------------------------------------


------------------------------------------------------------
-- (1) map odd [1,2,3,4,5]
------------------------------------------------------------
-- odd verifica se um número é ímpar.
--
-- Resultado:
--   [odd 1, odd 2, odd 3, odd 4, odd 5]
--   [True, False, True, False, True]
------------------------------------------------------------

expr1 :: [Bool]
expr1 = map odd [1,2,3,4,5]



------------------------------------------------------------
-- (2) filter odd [1,2,3,4,5]
------------------------------------------------------------
-- Mantém apenas os elementos ímpares.
--
-- Resultado:
--   [1,3,5]
------------------------------------------------------------

expr2 :: [Int]
expr2 = filter odd [1,2,3,4,5]



------------------------------------------------------------
-- (3) map (\x -> div x 3) [5,6,23,3]
------------------------------------------------------------
-- Aplica div x 3 a cada elemento.
--   div 5 3  = 1
--   div 6 3  = 2
--   div 23 3 = 7
--   div 3 3  = 1
--
-- Resultado:
--   [1,2,7,1]
------------------------------------------------------------

expr3 :: [Int]
expr3 = map (\x -> div x 3) [5,6,23,3]



------------------------------------------------------------
-- (4) filter (\y -> mod y 3 == 0) [5,6,23,3]
------------------------------------------------------------
-- Mantém quem é múltiplo de 3.
--   5 mod 3 = 2 → não entra
--   6 mod 3 = 0 → entra
--   23 mod 3 = 2 → não entra
--   3 mod 3 = 0 → entra
--
-- Resultado:
--   [6,3]
------------------------------------------------------------

expr4 :: [Int]
expr4 = filter (\y -> mod y 3 == 0) [5,6,23,3]



------------------------------------------------------------
-- (5) filter (7<) [1..15]
------------------------------------------------------------
-- (7<) é equivalente a (\x -> 7 < x)
-- Mantém números maiores que 7.
--
-- Resultado:
--   [8,9,10,11,12,13,14,15]
------------------------------------------------------------

expr5 :: [Int]
expr5 = filter (7<) [1..15]



------------------------------------------------------------
-- (6) map (7:) [[2,3],[1,5,3]]
------------------------------------------------------------
-- (7:) coloca o valor 7 no início de cada lista.
--
-- Resultado:
--   [[7,2,3], [7,1,5,3]]
------------------------------------------------------------

expr6 :: [[Int]]
expr6 = map (7:) [[2,3],[1,5,3]]



------------------------------------------------------------
-- (7) map (:[]) [1..5]
------------------------------------------------------------
-- (:[]) transforma cada elemento num singleton (lista com 1 elemento)
--
-- Resultado:
--   [[1],[2],[3],[4],[5]]
------------------------------------------------------------

expr7 :: [[Int]]
expr7 = map (:[]) [1..5]



------------------------------------------------------------
-- (8) map succ (filter odd [1..20])
------------------------------------------------------------
-- Primeiro filtra os ímpares → [1,3,5,..,19]
-- Depois aplica succ (sucessor, +1)
--
-- Resultado:
--   [2,4,6,..,20]
------------------------------------------------------------

expr8 :: [Int]
expr8 = map succ (filter odd [1..20])



------------------------------------------------------------
-- (9) filter odd (map succ [1..20])
------------------------------------------------------------
-- Primeiro aplica succ a todos → [2,3,4,..,21]
-- Depois filtra os ímpares → os números ímpares dessa lista
--
-- Resultado:
--   [3,5,7,..,21]
------------------------------------------------------------

expr9 :: [Int]
expr9 = filter odd (map succ [1..20])

------------------------------------------------------------
-- Observação:
-- expr8 ≠ expr9
-- porque mudar a ordem entre map e filter altera o resultado.
------------------------------------------------------------
